#include <stdio.h>
#include <string.h>

int main(void)
{
	/*输入数据*/
	char x[100];
	gets(x);
	char*p = x;
	char*q = p; //将p的地址再复映射，避免后期对p进行运算后造成变换 
	
	/*算法开始：解压字符串*/
	int count = 0; //记录位数，规避两位数的错误
	int flag =0; //通过flag进行标记进入那个位置 
	
	/*每个字符挨个扫描*/ 
	for(int i=0; i<strlen(x); i++)
	{
		
		//
		/*如果是字母，则先打印出来*/
		if( ((*p>='a') && (*p<='z')) || ((*p>='A') && (*p<='Z')) )
		{
			printf("%c", *p);
			p++;
		}
		/*如果是数字，那么说明前一个是字母，下一个就要分析数字是多少，进而打印出*/
		else
		{	
			//这里有个及其容易错误的点：当某些位置是两位数的时候就需要进行判断，且以下只适用于2位数的情况 
			count = count *10 + q[i] - '0';
			
			/*如果下一位是数字，则标记一个为1*/
			if((*(p+1)>='0') && (*(p+1)<='9')) //二次判断是否为两位数 
				{
					p++; 
					flag = 1;
					continue; 
				} 
			/*如果下一位不是数字，说明就只有一个数字*/
			else
			{
				if(flag == 0)
				{
					for(int j = 1; j<count; j++) //
						printf("%c", *(p-1));
					count = 0; //必须在输出数字倍数的字母之后才能初始化
				}
				if(flag == 1)
				{
					for(int j = 1; j<count; j++) //
						printf("%c", *(p-2));
					count = 0; //必须在输出数字倍数的字母之后才能初始化
					flag = 0; //进入这个情况后进行初始化 
				}
			}
			p++;
		}
		//
		
	}
	
}

//本题心得：这道题中应用了数组和指针，尽管指针让这个运算变得操作化强，但是同时也会增加许多指针变化的语句



